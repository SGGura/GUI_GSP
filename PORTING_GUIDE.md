# Руководство по портированию GUI_GSP на новый дисплей

**English:** [PORTING_GUIDE_EN.md](PORTING_GUIDE_EN.md) · **Українська:** [PORTING_GUIDE_UK.md](PORTING_GUIDE_UK.md)

---

**Библиотека графического интерфейса для систем с малым экраном и одним буфером кадра.**  
Полная пошаговая инструкция для разработчиков: что такое GUI_GSP, какие у неё возможности, как портировать на свой дисплей и как использовать шрифты [LVGL](https://lvgl.io/).

---

## Содержание

1. [О библиотеке: малый экран, один буфер](#1-о-библиотеке-малый-экран-один-буфер)
2. [Возможности библиотеки](#2-возможности-библиотеки)
3. [Совместимость со шрифтами LVGL](#3-совместимость-со-шрифтами-lvgl)
4. [Для кого эта инструкция](#4-для-кого-эта-инструкция)
5. [Главная идея портирования](#5-главная-идея-портирования)
6. [Быстрый старт](#6-быстрый-старт)
7. [Подробные шаги портирования](#7-подробные-шаги-портирования)
8. [Формат буфера экрана](#8-формат-буфера-экрана)
9. [Дополнительные возможности](#9-дополнительные-возможности)
10. [Подробности: виджеты, память, таймер](#10-подробности-виджеты-память-таймер)
11. [Чек-лист и важные файлы](#11-чек-лист-и-важные-файлы)
12. [Подключение в вашем коде](#12-подключение-в-вашем-коде)
13. [Частые вопросы](#13-частые-вопросы)

---

## 1. О библиотеке: малый экран, один буфер

**GUI_GSP** предназначена для **встраиваемых графических систем с малым экраном** (например, 128×64, 96×64, 128×32 пикселей) и **одним буфером кадра**.

- **Малый экран** — типичные монохромные или простые цветные дисплеи на контроллерах SSD1306, SH1107 и аналогичных, используемые в приборах, панелях, измерителях.
- **Один буфер экрана** — библиотека хранит **единственный** массив пикселей (`Mem_LCD`). Весь интерфейс рисуется в этот буфер; затем буфер целиком отправляется на дисплей. Двойной буфер (double buffering) не используется: это уменьшает потребление RAM и упрощает портирование на маломощные МК (в т.ч. PIC).

Таким образом, GUI_GSP оптимизирована под ограниченную память и простой цикл: «нарисовать кадр в буфер → вывести буфер на дисплей».

---

## 2. Возможности библиотеки

### 2.1. Графика и экран

- **Один общий буфер кадра** — монохром 1 bpp (бит на пиксель). Размер буфера: `(SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8` байт.
- **Вся отрисовка внутри библиотеки** — точки, линии, прямоугольники, заливка, вывод растровых изображений. Прикладной код не реализует низкоуровневую графику.
- **Экраны (Screen)** — переключение между «экранами» (окнами), у каждого экрана — свой набор виджетов и обработчик клавиш.
- **Безопасное переключение экранов** — `GUI_SwitchScreen(create_func)` и `GUI_IsScreenSwitchPending()` для смены экрана без обращения к освобождённым виджетам.

### 2.2. Виджеты

| Виджет | Назначение |
|--------|------------|
| **Screen** | Контейнер экрана: координаты, размер, цвет фона, рамка, список виджетов, обработчик клавиш. |
| **Label** | Текст с выравниванием, атрибутами (мигание, сдвиг, включён/выключен), поддержка бегущей строки (циклическая/бесконечная). |
| **Table** | Таблица ячеек на основе Label. |
| **List** | Список строк с прокруткой и бегущей строкой. |
| **Chart** | Графики: линейный график, гистограмма, сдвиг данных (опции в конфиге). |
| **Ruler** | Линейка (шкала). |
| **Image** | Вывод изображений из кода (массивы) или из внешней памяти (FLASH). Поддержка **анимации**: последовательность кадров с заданным интервалом (мс), режимы — цикл, один раз, туда-обратно (ping-pong); ImageSetFrames / ImageSetFramesEx, пауза/возобновление. |
| **Line (PolyLine)** | Линии (примитив). |
| **ProgressBar** | Прогресс-бар. |
| **Spinner** | Спиннер (индикатор ожидания). |
| **Panel** | Панель (контейнер/рамка). |
| **Timer** | Виджет **GSP_Timer**: таймеры, привязанные к экрану — периодический вызов callback (CreateTimer, period_ms, count). Используется для периодических действий и для привязки анимаций. |
| **Message** | Диалоги сообщений. |
| **Keyboard** | Виджет экранной клавиатуры. |

Состав виджетов настраивается в конфиге (`USED_LABEL`, `USED_TABLE`, `USED_CHART` и т.д.) — неиспользуемые можно отключить для экономии кода.

### 2.3. Текст и шрифты

- **Вывод текста в формате UTF-8** — через `DrawTextUTF8` и родственные функции (`GSP_DrawText.c`).
- **Шрифты в формате [LVGL](https://lvgl.io/)** — структура `lv_font_t`, формат lv_font_fmt_txt. Можно использовать как встроенные в прошивку шрифты, так и шрифты, загружаемые из FLASH/внешней памяти. Подробно — раздел 3.
- **Шрифт по умолчанию** — задаётся макросом `DEFAULT_FONT` в `GUI_GSP_Config.h`; для виджетов можно задавать шрифт явно.

### 2.4. Многоязычность и данные извне

- **Языковые пакеты** — смена языка, строки интерфейса, шрифты для языков (в т.ч. загрузка шрифтов из FLASH через `lv_font_load`). При сборке пакета **рядом с каждым .json** должны лежать используемые в пакете сконвертированные шрифты LVGL с расширением **.bin** (см. MEDIA_AND_LANG_PACK).
- **Внешняя память** — единый callback `ExternalMemoryCallback` для чтения шрифтов и изображений из FLASH или внешней SPI-FLASH (опции `USE_FONT_FLASH`, `USE_BITMAP_EXTERNAL`).

### 2.5. Управление и таймер

- **Клавиатура** — опрос кнопок через `GSP_KeyPoll()` и `GSP_ReadKey()`; привязка к экрану через `KeyHandler`.
- **Таймер GUI** — в обработчике прерывания таймера обязательно вызывать **GUI_TimerClock(period_ms)** с параметром, равным периоду прерывания в миллисекундах (например, 10 мс).
- **Подсветка** — при необходимости реализуется `SetBright(light)` в вашем коде (ШИМ или дискретный вывод).

Итого: библиотека даёт готовый набор виджетов, текст с UTF-8 и шрифтами [LVGL](https://lvgl.io/), работу с одним буфером кадра и минимум требований к портированию — инициализация дисплея и вывод буфера на экран.

---

## 3. Совместимость со шрифтами LVGL

Библиотека **полностью совместима со шрифтами [LVGL](https://lvgl.io/)**: используются те же структуры данных и формат шрифта (lv_font_fmt_txt), что и в LVGL 8.x. Это позволяет применять [инструменты LVGL](https://lvgl.io/tools) и готовые шрифты без переделки.

### 3.1. Формат и типы

- **Тип шрифта:** `lv_font_t` (описан в `Fonts/LVGL/GSP_lvgl.h`).
- **Формат хранения:** **lv_font_fmt_txt** — битмапы глифов, дескрипторы глифов (`lv_font_fmt_txt_glyph_dsc_t`), таблицы отображения символов (cmap), при необходимости кернинг. Структуры совместимы с [LVGL Font Converter](https://lvgl.io/tools/fontconverter).
- **Битность:** поддерживаются шрифты с 1, 2, 3, 4, 8 bpp (в т.ч. монохром 1 bpp для малых экранов).

Таким образом, любой шрифт, сгенерированный под [LVGL](https://lvgl.io/) (например, [LVGL Font Converter](https://lvgl.io/tools/fontconverter)), можно использовать в GUI_GSP без изменения формата.

### 3.2. Встроенные шрифты (в прошивке)

В библиотеке можно использовать **два источника шрифтов**:

1. **Шрифты в формате C** — сконвертированные в `.c` (как **lv_font_unscii_8.c**): подключаете файл к проекту, объявляете в **Fonts.h**, в коде передаёте `&lv_font_unscii_8`. В языковом пакете в JSON можно указать имя `"lv_font_unscii_8"` — **файл .bin рядом с JSON не нужен**, библиотека подставит встроенный шрифт.
2. **Шрифты из FLASH** — конвертированные в **Binary** (`.bin`), положенные рядом с `.json` и загружаемые через **lv_font_load** из пакета (см. раздел 3.4 и MEDIA_AND_LANG_PACK).

В **`GUI_GSP/Fonts/Fonts.h`** объявлены шрифты, подключаемые исходниками (`.c`) в сборку:

| Шрифт | Описание |
|-------|----------|
| **lv_font_unscii_8** | Базовый 8×8, ASCII (часто используется как шрифт по умолчанию). |
| **lv_font_unscii_16** | Увеличенный unscii. |
| **font_5x7_16**, **Pocket_Mem_16**, **Ithaca_16** | Дополнительные шрифты. |
| **AllLangFont** | Указатель на шрифт для названий языков (может загружаться из FLASH). |

В виджетах (Label, List, Table, Message, Keyboard и т.д.) передаётся указатель на `lv_font_t` (например, `&lv_font_unscii_8` или шрифт из FLASH).

### 3.3. Шрифт по умолчанию (DEFAULT_FONT)

В **`GUI_GSP/Config/GUI_GSP_Config.h`** задаётся шрифт по умолчанию для виджетов:

```c
#define DEFAULT_FONT  &lv_font_unscii_8
```

Его можно заменить на любой другой встроенный шрифт из **Fonts.h** (например, `&lv_font_unscii_16`). Если шрифт у виджета не задан явно, используется `DEFAULT_FONT`.

### 3.4. Загрузка шрифтов из FLASH (внешней памяти)

При включённой опции **USE_FONT_FLASH** и корректно заполненном **GSP_HW.memory_read** библиотека может **загружать шрифты динамически** из FLASH или внешней памяти:

- **lv_font_load()** (в `GSP_lv_font_loader.c`) читает бинарный шрифт по адресу через **ExternalMemoryCallback** / **memory_read**.
- Возвращается `lv_font_t *`, который можно передать в виджет или в систему языков.
- После использования шрифт освобождается вызовом **lv_font_free(font)**.

В языковых пакетах при смене языка (**Load_Langs**) шрифты для строк могут загружаться из пакета (FLASH) через **lv_font_load** и сохраняться в **Ext_Fonts[]** и **AllLangFont**.

### 3.5. Как получить шрифты в формате LVGL

- **[LVGL Font Converter](https://lvgl.io/tools/fontconverter)** ([LVGL](https://lvgl.io/)): загружаете TTF/WOFF, задаёте размер, диапазон символов (в т.ч. кириллицу), битность, и получаете:
  - **C array** — файл `.c` с массивом данных (как **lv_font_unscii_8.c** в репозитории): подключаете к проекту, объявляете в **Fonts.h**; в коде используете `&lv_font_unscii_8`; в JSON языкового пакета можно указать имя `"lv_font_unscii_8"` — **.bin не нужен**. Дополнительные C-шрифты можно добавить в таблицу встроенных в **GSP_Langs.c** (массив `builtin_fonts`).
  - **Binary** — бинарный файл (`.bin`) для размещения во внешней памяти и загрузки через **lv_font_load**; кладётся рядом с `.json` при сборке пакета (см. MEDIA_AND_LANG_PACK).
- **Данные для FLASH** (шрифты, изображения, ресурсы) можно подготавливать утилитой [Microchip](https://www.microchip.com/) **grc.jar** (Graphics Resource Converter): она входит в состав инструментария Microchip и конвертирует шрифты и изображения в форматы для размещения во внешней/внутренней памяти. Запуск: `grc.jar` (Linux/macOS) или `launch_grc.bat` (Windows). Документация: [Microchip Developer Help — Graphics](https://developerhelp.microchip.com/xwiki/bin/view/software-tools/mgs/mgs-harmony-guide/gfx-assets/).
- Сгенерированные шрифты **без изменений** совместимы с GUI_GSP: структура `lv_font_t` и формат lv_font_fmt_txt совпадают с используемым в библиотеке.

### 3.6. UTF-8 и вывод текста

Вывод текста идёт через **DrawTextUTF8** и родственные функции (**GSP_DrawText.c**) с поддержкой **UTF-8**. Шрифт передаётся как `lv_font_t *font`. Для кириллицы и других символов в шрифте при конвертации нужно указать соответствующий диапазон глифов в Font Converter.

**Итог по [LVGL](https://lvgl.io/):** библиотека использует те же шрифты и формат, что и LVGL 8.x. Можно применять **шрифты в C** (`.c` в проекте, как **lv_font_unscii_8.c**), **шрифты из FLASH** (`.bin` в пакете) или комбинацию; шрифт по умолчанию задаётся **DEFAULT_FONT** в конфиге.

---

## 4. Для кого эта инструкция

- Вы переносите проект с GUI_GSP на **другой микроконтроллер** или **другой дисплей**.
- Вы подключаете библиотеку GUI_GSP к **новому проекту**.
- Вы хотите понять, **что именно нужно реализовать** со своей стороны.

**Что не требуется:** писать низкоуровневую графику (точки, линии, прямоугольники, картинки) — это уже сделано в библиотеке. Нужно только **инициализировать дисплей** и **выводить готовый кадр** на экран.

---

## 5. Главная идея портирования

Библиотека хранит **один буфер кадра** (массив пикселей) и сама рисует в него виджеты, текст и графику. Ваша задача — **два действия**:

| № | Ваша функция | Что она делает |
|---|--------------|----------------|
| 1 | **Init_LCD()** | Один раз при старте настраивает дисплей (пины, SPI/I2C, команды контроллера). |
| 2 | **Refresh_LCD(buffer)** | По вызову библиотеки отправляет готовый буфер кадра на физический дисплей. |

Схема работы:

```
  Ваше приложение (экраны, кнопки)
           │
           ▼
  Библиотека GUI_GSP (виджеты, рисование в буфер Mem_LCD[])
           │
           ▼
  GSP_Display_Refresh()  ──►  вызывает вашу Refresh_LCD(Mem_LCD)
           │
           ▼
  Ваш код: отправка буфера по SPI/I2C/параллельному порту на дисплей
```

**Важно:** функции PutPixel, Line, Bar, SetColor и т.п. **реализовывать не нужно** — они уже есть в библиотеке и работают с её единственным буфером.

---

## 6. Быстрый старт

1. **Создать** свой модуль дисплея (например, `Graphics/MyDisplay.c` и `MyDisplay.h`).
2. **Реализовать** в нём:
   - `void Init_LCD(void)` — инициализация железа.
   - `void Refresh_LCD(unsigned char *buffer)` — вывод `buffer` на дисплей (размер и формат — раздел 8).
3. **Задать** в `GUI_GSP/Config/GUI_GSP_Config.h` размеры: `SCREEN_HOR_SIZE`, `SCREEN_VER_SIZE`.
4. **В** `GUI_GSP/Drivers/GSP_Hardware.c`:
   - подключить ваш заголовок с объявлениями `Init_LCD` и `Refresh_LCD`;
   - в структуре `GSP_HW` указать: `.display.Init = Init_LCD`, `.display.Refresh = GSP_Display_Refresh`.
5. **Добавить** ваш `MyDisplay.c` в сборку проекта.

Дальше — раздел 7 (подробные шаги).

---

## 7. Подробные шаги портирования

### Шаг 1. Создать модуль дисплея

- **Заголовок** (например, `Graphics/MyDisplay.h`):

```c
#ifndef MY_DISPLAY_H
#define MY_DISPLAY_H

void Init_LCD(void);
void Refresh_LCD(unsigned char *buffer);

#endif
```

- **Реализация** (например, `Graphics/MyDisplay.c`): своя инициализация (GPIO, SPI, команды контроллера) и отправка буфера на дисплей. Пример заглушки:

```c
#include "MyDisplay.h"

void Init_LCD(void)
{
    // Настроить пины (CS, DC, RST, CLK, DATA…)
    // Настроить SPI или другой интерфейс
    // Отправить последовательность команд инициализации контроллера
}

void Refresh_LCD(unsigned char *buffer)
{
    // buffer — массив размером (SCREEN_HOR_SIZE * SCREEN_VER_SIZE) / 8 байт
    // Отправить на дисплей: постранично или целиком — как требует контроллер
}
```

Размер и формат буфера — раздел 8.

---

### Шаг 2. Задать размеры экрана

В **`GUI_GSP/Config/GUI_GSP_Config.h`**:

```c
#define SCREEN_HOR_SIZE    128   // ширина в пикселях
#define SCREEN_VER_SIZE    64    // высота в пикселях
```

Размер буфера: **SIZE_DISP = (SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8** байт (для 128×64 — 1024 байта).

---

### Шаг 3. Подключить дисплей в GSP_Hardware

В **`GUI_GSP/Drivers/GSP_Hardware.c`**:

1. Подключить заголовок с `Init_LCD` и `Refresh_LCD`.
2. В структуре **GSP_HW** в блоке `.display` задать:
   - **Refresh** = **GSP_Display_Refresh** (библиотека внутри вызовет вашу **Refresh_LCD(Mem_LCD)**);
   - **Init** = **Init_LCD**.

Остальные поля (клавиатура, stream_reader, memory_read, alloc/free) — по необходимости (раздел 9).

---

### Шаг 4. Добавить файлы в проект

В настройках проекта добавить в сборку ваш модуль дисплея (например, `MyDisplay.c`). При замене старого дисплея — убрать из сборки старый модуль.

---

## 8. Формат буфера экрана

В **Refresh_LCD(unsigned char *buffer)** передаётся буфер с уже нарисованным кадром.

- **Размер:** `SIZE_DISP = (SCREEN_HOR_SIZE * SCREEN_VER_SIZE) / 8` байт.
- **Организация (1 bpp, монохром):** один байт — 8 пикселей по вертикали (страница высотой 8 строк). Пиксели по столбцам: столбец 0 строки 0–7, затем столбец 1 строки 0–7 и т.д.

**Индекс байта:** `индекс = (y / 8) * SCREEN_HOR_SIZE + x` (x — столбец, y — строка).  
**Биты в байте:** младший бит (bit 0) — меньший y в восьмёрке, старший (bit 7) — больший y.

**Значение пикселя:** бит = 1 — светлый, бит = 0 — тёмный. Многие контроллеры (SSD1306, SH1107) используют такой же формат; иначе преобразование делается внутри вашей **Refresh_LCD**.

---

## 9. Дополнительные возможности

В **GSP_Hardware.c** помимо дисплея настраиваются:

- **Клавиатура** — `.keyboard.key_poll`, `.keyboard.read_key`; в приложении — **GSP_KeyPoll()**, **GSP_ReadKey()**.
- **Подсветка** — реализация **SetBright(light)** в вашем модуле (или заглушка).
- **Внешняя память** — **memory_read** (callback чтения по смещению и длине), **stream_reader** (потоковое чтение для JSON и т.п.).
- **Аллокатор** — **GSP_HW.alloc**, **GSP_HW.free** (по умолчанию можно использовать malloc/free или, например, **user_malloc/user_free** из **GSP_mem_monitor**).

Неиспользуемые указатели можно оставлять **NULL**; библиотека проверяет их перед вызовом.

---

## 10. Подробности: виджеты, память, таймер

### 10.1. Конфигурация виджетов и цветов

В **GUI_GSP/Config/GUI_GSP_Config.h** задаются макросы **USED_*** (USED_LABEL, USED_TABLE, USED_LIST, USED_CHART, USED_IMAGE, USED_PROGRESSBAR, USED_SPINNER, USED_PANEL, USED_LINE, USED_TIMER, USED_MESSAGE, USED_KEYBOARD). Отключение ненужных виджетов уменьшает размер кода. Там же — цвета по умолчанию (DEFAULT_COLOR_*) и опции графиков (CHART_ENABLE_*).

### 10.2. Внешняя память: шрифты и изображения

Чтение данных из FLASH/внешней памяти — через **ExternalMemoryCallback** (сигнатура в конфиге), присваивается в **GSP_HW.memory_read**. Используется загрузчиком шрифтов (**lv_font_load**) при **USE_FONT_FLASH** и выводом изображений (**PutImage**) при **USE_BITMAP_EXTERNAL**.

### 10.3. Формат шрифта во внешней памяти

Шрифт во внешней памяти должен быть в **бинарном формате [LVGL](https://lvgl.io/)** (экспорт [LVGL Font Converter](https://lvgl.io/tools/fontconverter) в **Binary**). Структура: секции head, cmap, loca, glyph (и опционально kern). Загрузчик **lv_font_load** читает их через **ExternalMemoryCallback**; по адресу **EXTDATA.address** должен лежать целый бинарный файл шрифта LVGL. Данные для записи во FLASH (шрифты, изображения) можно подготавливать утилитой [Microchip](https://www.microchip.com/) **grc.jar** (Graphics Resource Converter); см. [документацию Microchip по графическим ресурсам](https://developerhelp.microchip.com/xwiki/bin/view/software-tools/mgs/mgs-harmony-guide/gfx-assets/).

### 10.4. Формат изображения во внешней памяти

При **USE_BITMAP_EXTERNAL**: по адресу **EXTDATA.address** — заголовок (compression, colorDepth, height, width), палитра (два unsigned short для 1 bpp), затем построчно данные 1 bpp. Чтение — через **ExternalMemoryCallback**.

### 10.5. Виджет GSP_Timer

При опции **USED_TIMER** доступен виджет **GSP_Timer** — таймеры, привязанные к экрану. Они периодически вызывают заданный callback и удобны для обновления данных, опроса датчиков или синхронизации с анимацией.

- **CreateTimer(Screen, TimerFuncPtr, period_ms, count)** — создать таймер: вызов `TimerFuncPtr(timer)` каждые `period_ms` мс; `count` — число срабатываний (−1 — бесконечно).
- **DeleteAllTimers(Screen)**, **PauseAllTimers(Screen)**, **ResumeAllTimers(Screen)** — удалить все таймеры экрана, приостановить или возобновить.
- **Set_GSP_Timer_Period(Timer, period)** — изменить период таймера.

Таймеры обрабатываются внутри **GUI_Run()** по глобальному счётчику **Timer_GUI**, который обновляется вызовом **GUI_TimerClock(period_ms)** в обработчике прерывания таймера (см. п. 10.6).

### 10.6. Анимация вывода картинок (Image)

Виджет **Image** поддерживает **анимацию** — поочерёдный вывод кадров (массив картинок) с заданным интервалом. Тайминг основан на **Timer_GUI**, поэтому для работы анимации в прерывании таймера должен вызываться **GUI_TimerClock(period_ms)**.

- **Режимы анимации** (GSP_Image.h): **GSP_ANIM_MODE_LOOP** (цикл), **GSP_ANIM_MODE_ONCE** (один раз, затем остановка), **GSP_ANIM_MODE_PINGPONG** (туда-обратно), **GSP_ANIM_MODE_REVERSE** (обратный цикл).
- **ImageSetFrames(img, frames, n, time)** — задать массив кадров `frames`, количество кадров `n`, интервал между кадрами `time` (мс).
- **ImageSetFramesEx(img, frames, n, time, mode)** — то же с явным режимом анимации.
- **ImageStartAnimation(img)**, **ImageStopAnimation(img)**, **ImagePauseAnimation(img)**, **ImageResumeAnimation(img)**, **ImageRestartAnimation(img)** — управление воспроизведением.
- **ImageSetAnimationMode(img, mode)** — смена режима; **ImageGetCurrentFrame(img)**, **ImageIsAnimationPlaying(img)** — состояние анимации.

Мерцание виджета Image задаётся **ImageSetBlink(img, blink_time)** (0 — выключить).

### 10.7. Таймер и основной цикл

- **В основном цикле** должен вызываться **только** **GUI_Run()** — внутри него выполняются опрос клавиатуры, обновление экрана и вся логика GUI.
- **В обработчике прерывания таймера** обязательно вызывать **GUI_TimerClock(period_ms)** с параметром, равным периоду прерывания в миллисекундах (например, при периоде 10 мс — **GUI_TimerClock(10)**). Это нужно для работы виджетов **GSP_Timer**, анимации изображений (Image) и других виджетов, использующих Timer_GUI.

Пример: основной цикл и вызов в таймере:

```c
// Основной цикл приложения — только GUI_Run()
while (1) {
    GUI_Run();
}

// В обработчике прерывания таймера (период, например, 10 мс):
GUI_TimerClock(10);   // 10 — период прерывания в мс
```

---

## 11. Чек-лист и важные файлы

### Чек-лист портирования

- [ ] Создан модуль дисплея с **Init_LCD()** и **Refresh_LCD(unsigned char *buffer)**.
- [ ] В конфиге заданы **SCREEN_HOR_SIZE** и **SCREEN_VER_SIZE**.
- [ ] В **GSP_Hardware.c** подключён заголовок и заданы **GSP_HW.display.Refresh = GSP_Display_Refresh**, **GSP_HW.display.Init = Init_LCD**.
- [ ] При необходимости заполнены клавиатура, stream_reader, memory_read, alloc/free, SetBright.
- [ ] Модуль дисплея добавлен в сборку.

### Важные файлы

| Файл | Назначение |
|------|------------|
| **GUI_GSP/Drivers/GSP_Driver.h**, **GSP_Driver.c** | Буфер Mem_LCD, графика, вызов Refresh_LCD и Init_LCD. |
| **GUI_GSP/Drivers/GSP_Hardware.c** | Настройка GSP_HW под проект (дисплей, клавиатура, память, аллокатор). |
| **GUI_GSP/Config/GUI_GSP_Config.h** | Размеры экрана, цвета, шрифты, опции виджетов. |
| **GUI_GSP/Fonts/Fonts.h**, **Fonts/LVGL/GSP_lvgl.h** | Шрифты [LVGL](https://lvgl.io/), тип lv_font_t. |
| **GUI_GSP/Fonts/LVGL/GSP_lv_font_loader.c** | lv_font_load / lv_font_free для загрузки шрифтов из FLASH. |

---

## 12. Подключение в вашем коде

```c
#include "GUI_GSP/GUI_GSP.h"
#include "Langs.h"
```

Через **GUI_GSP.h** подтягиваются конфиг, драйвер и виджеты.

---

## 13. Частые вопросы

**Нужно ли реализовывать PutPixel, Line, Bar?**  
Нет. Вся графика в библиотеке, рисует в один буфер. Нужны только Init_LCD и Refresh_LCD.

**Что передаётся в Refresh_LCD?**  
Указатель на буфер библиотеки (Mem_LCD). Размер: **(SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8** байт. Формат — раздел 8.

**Можно ли другой размер экрана?**  
Да. Задайте **SCREEN_HOR_SIZE** и **SCREEN_VER_SIZE** в конфиге.

**Нет клавиатуры / потокового чтения / внешней памяти.**  
Соответствующие поля в GSP_HW можно оставить NULL.

**Контроллер дисплея ожидает другой порядок страниц или бит.**  
Преобразование делайте внутри вашей **Refresh_LCD**.

**Можно ли использовать шрифты LVGL?**  
Да. Библиотека полностью совместима со шрифтами [LVGL](https://lvgl.io/) (lv_font_t, lv_font_fmt_txt): встроенные из **Fonts.h**, **DEFAULT_FONT** в конфиге, при **USE_FONT_FLASH** — загрузка из FLASH через **lv_font_load**. Подробно — раздел 3.

---

*Конец руководства.*
