# Посібник з портування GUI_GSP на новий дисплей

**Русская версия:** [PORTING_GUIDE.md](PORTING_GUIDE.md) · **English:** [PORTING_GUIDE_EN.md](PORTING_GUIDE_EN.md)

---

**Бібліотека графічного інтерфейсу для систем з малим екраном та одним буфером кадру.**  
Покрокова інструкція для розробників: що таке GUI_GSP, її можливості, як портувати на свій дисплей та як використовувати шрифти [LVGL](https://lvgl.io/).

---

## Зміст

1. [Про бібліотеку: малий екран, один буфер](#1-про-бібліотеку-малий-екран-один-буфер)
2. [Можливості бібліотеки](#2-можливості-бібліотеки)
3. [Сумісність із шрифтами LVGL](#3-сумісність-із-шрифтами-lvgl)
4. [Для кого ця інструкція](#4-для-кого-ця-інструкція)
5. [Головна ідея портування](#5-головна-ідея-портування)
6. [Швидкий старт](#6-швидкий-старт)
7. [Покрокове портування](#7-покрокове-портування)
8. [Формат буфера екрана](#8-формат-буфера-екрана)
9. [Додаткові можливості](#9-додаткові-можливості)
10. [Подробиці: віджети, пам'ять, таймер](#10-подробиці-віджети-память-таймер)
11. [Чек-лист та важливі файли](#11-чек-лист-та-важливі-файли)
12. [Підключення у вашому коді](#12-підключення-у-вашому-коді)
13. [Часті питання](#13-часті-питання)

---

## 1. Про бібліотеку: малий екран, один буфер

**GUI_GSP** призначена для **вбудованих графічних систем з малим екраном** (наприклад, 128×64, 96×64, 128×32 пікселів) та **одним буфером кадру**.

- **Малий екран** — типові монохромні або прості кольорові дисплеї на контролерах SSD1306, SH1107 та подібних, що використовуються в приладах, панелях, вимірювачах.
- **Один буфер екрана** — бібліотека зберігає **єдиний** масив пікселів (`Mem_LCD`). Весь інтерфейс малюється в цей буфер; потім буфер цілком відправляється на дисплей. Подвійний буфер (double buffering) не використовується: це зменшує споживання RAM і спрощує портування на малопотужні МК (зокрема PIC).

Таким чином, GUI_GSP оптимізована під обмежену пам'ять та простий цикл: «намалювати кадр у буфер → вивести буфер на дисплей».

---

## 2. Можливості бібліотеки

### 2.1. Графіка та екран

- **Один спільний буфер кадру** — монохром 1 bpp (біт на піксель). Розмір буфера: `(SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8` байт.
- **Вся відмальовка всередині бібліотеки** — точки, лінії, прямокутники, заливка, вивід растрових зображень. Код застосунку не реалізує низькорівневу графіку.
- **Екрани (Screen)** — перемикання між «екранами» (вікнами), у кожного екрана — свій набір віджетів та обробник клавіш.
- **Безпечне перемикання екранів** — `GUI_SwitchScreen(create_func)` та `GUI_IsScreenSwitchPending()` для зміни екрана без звернення до звільнених віджетів.

### 2.2. Віджети

| Віджет | Призначення |
|--------|-------------|
| **Screen** | Контейнер екрана: координати, розмір, колір фону, рамка, список віджетів, обробник клавіш. |
| **Label** | Текст із вирівнюванням, атрибутами (мигання, зсув, ввімкнено/вимкнено), підтримка бігущої рядки (циклічна/нескінченна). |
| **Table** | Таблиця комірок на основі Label. |
| **List** | Список рядків із прокруткою та бігущою рядкою. |
| **Chart** | Графіки: лінійний графік, гістограма, зсув даних (опції в конфігу). |
| **Ruler** | Лінійка (шкала). |
| **Image** | Вивід зображень із коду (масиви) або з зовнішньої пам'яті (FLASH). Підтримка **анімації**: послідовність кадрів із заданим інтервалом (мс), режими — цикл, один раз, туди-назад (ping-pong); ImageSetFrames / ImageSetFramesEx, пауза/відновлення. |
| **Line (PolyLine)** | Лінії (примітив). |
| **ProgressBar** | Прогрес-бар. |
| **Spinner** | Спіннер (індикатор очікування). |
| **Panel** | Панель (контейнер/рамка). |
| **Timer** | Віджет **GSP_Timer**: таймери, прив'язані до екрана — періодичний виклик callback (CreateTimer, period_ms, count). Використовується для періодичних дій та для прив’язки анімацій. |
| **Message** | Діалоги повідомлень. |
| **Keyboard** | Віджет екранної клавіатури. |

Склад віджетів налаштовується в конфігу (`USED_LABEL`, `USED_TABLE`, `USED_CHART` тощо) — непотрібні можна вимкнути для економії коду.

### 2.3. Текст та шрифти

- **Вивід тексту у форматі UTF-8** — через `DrawTextUTF8` та пов’язані функції (`GSP_DrawText.c`).
- **Шрифти у форматі [LVGL](https://lvgl.io/)** — структура `lv_font_t`, формат lv_font_fmt_txt. Можна використовувати як вбудовані в прошивку шрифти, так і шрифти, що завантажуються з FLASH/зовнішньої пам'яті. Детально — розділ 3.
- **Шрифт за замовчуванням** — задається макросом `DEFAULT_FONT` у `GUI_GSP_Config.h`; для віджетів можна задавати шрифт явно.

### 2.4. Багатомовність та дані зовні

- **Мовні пакети** — зміна мови, рядки інтерфейсу, шрифти для мов (зокрема завантаження шрифтів з FLASH через `lv_font_load`). При збірці пакета **поруч із кожним .json** мають лежати використовувані в пакеті сконвертовані шрифти LVGL з розширенням **.bin** (див. MEDIA_AND_LANG_PACK).
- **Зовнішня пам'ять** — єдиний callback `ExternalMemoryCallback` для читання шрифтів та зображень з FLASH або зовнішньої SPI-FLASH (опції `USE_FONT_FLASH`, `USE_BITMAP_EXTERNAL`).

### 2.5. Керування та таймер

- **Клавіатура** — опитування кнопок через `GSP_KeyPoll()` та `GSP_ReadKey()`; прив’язка до екрана через `KeyHandler`.
- **Таймер GUI** — у обробнику переривання таймера обов’язково викликати **GUI_TimerClock(period_ms)** з параметром, рівним періоду переривання в мілісекундах (наприклад, 10 мс).
- **Підсвітка** — за потреби реалізується `SetBright(light)` у вашому коді (ШІМ або дискретний вивід).

Підсумок: бібліотека дає готовий набір віджетів, текст з UTF-8 та шрифтами [LVGL](https://lvgl.io/), роботу з одним буфером кадру та мінімум вимог до портування — ініціалізація дисплея та вивід буфера на екран.

---

## 3. Сумісність із шрифтами LVGL

Бібліотека **повністю сумісна зі шрифтами [LVGL](https://lvgl.io/)**: використовуються ті самі структури даних та формат шрифту (lv_font_fmt_txt), що й у LVGL 8.x. Це дозволяє застосовувати [інструменти LVGL](https://lvgl.io/tools) та готові шрифти без переробки.

### 3.1. Формат та типи

- **Тип шрифту:** `lv_font_t` (описано в `Fonts/LVGL/GSP_lvgl.h`).
- **Формат зберігання:** **lv_font_fmt_txt** — бітмапи гліфів, дескриптори гліфів (`lv_font_fmt_txt_glyph_dsc_t`), таблиці відображення символів (cmap), за потреби кернінг. Структури сумісні з [LVGL Font Converter](https://lvgl.io/tools/fontconverter).
- **Бітність:** підтримуються шрифти з 1, 2, 3, 4, 8 bpp (зокрема монохром 1 bpp для малих екранів).

Таким чином, будь-який шрифт, згенерований під [LVGL](https://lvgl.io/) (наприклад, [LVGL Font Converter](https://lvgl.io/tools/fontconverter)), можна використовувати в GUI_GSP без зміни формату.

### 3.2. Вбудовані шрифти (у прошивці)

У **`GUI_GSP/Fonts/Fonts.h`** оголошені шрифти, що підключаються вихідниками (`.c`) до збірки:

| Шрифт | Опис |
|-------|------|
| **lv_font_unscii_8** | Базовий 8×8, ASCII (часто використовується як шрифт за замовчуванням). |
| **lv_font_unscii_16** | Збільшений unscii. |
| **font_5x7_16**, **Pocket_Mem_16**, **Ithaca_16** | Додаткові шрифти. |
| **AllLangFont** | Вказівник на шрифт для назв мов (може завантажуватися з FLASH). |

У віджетах (Label, List, Table, Message, Keyboard тощо) передається вказівник на `lv_font_t` (наприклад, `&lv_font_unscii_8` або `&GSP_Arial_16` з `GUI_GSP.h`).

### 3.3. Шрифт за замовчуванням (DEFAULT_FONT)

У **`GUI_GSP/Config/GUI_GSP_Config.h`** задається шрифт за замовчуванням для віджетів:

```c
#define DEFAULT_FONT  &lv_font_unscii_8
```

Його можна замінити на будь-який інший вбудований шрифт з **Fonts.h** (наприклад, `&lv_font_unscii_16`). Якщо шрифт у віджета не задано явно, використовується `DEFAULT_FONT`.

### 3.4. Завантаження шрифтів з FLASH (зовнішньої пам'яті)

При увімкненій опції **USE_FONT_FLASH** та коректно заповненому **GSP_HW.memory_read** бібліотека може **завантажувати шрифти динамічно** з FLASH або зовнішньої пам'яті:

- **lv_font_load()** (у `GSP_lv_font_loader.c`) читає бінарний шрифт за адресою через **ExternalMemoryCallback** / **memory_read**.
- Повертається `lv_font_t *`, який можна передати у віджет або в систему мов.
- Після використання шрифт звільняється викликом **lv_font_free(font)**.

У мовних пакетах при зміні мови (**Load_Langs**) шрифти для рядків можуть завантажуватися з пакета (FLASH) через **lv_font_load** та зберігатися в **Ext_Fonts[]** та **AllLangFont**.

### 3.5. Як отримати шрифти у форматі LVGL

- **[LVGL Font Converter](https://lvgl.io/tools/fontconverter)** ([LVGL](https://lvgl.io/)): завантажуєте TTF/WOFF, задаєте розмір, діапазон символів (зокрема кирилицю), бітність і отримуєте:
  - **C array** — файл `.c` з масивом даних; підключаєте до проекту та оголошуєте шрифт у **Fonts.h**.
  - **Binary** — бінарний файл для розміщення у зовнішній пам'яті та завантаження через **lv_font_load** (формат описано в розділі 10).
- **Дані для FLASH** (шрифти, зображення, ресурси) можна готувати утилітою [Microchip](https://www.microchip.com/) **grc.jar** (Graphics Resource Converter): вона входить до складу інструментарію Microchip та конвертує шрифти та зображення у формати для розміщення у зовнішній/внутрішній пам'яті. Запуск: `grc.jar` (Linux/macOS) або `launch_grc.bat` (Windows). Документація: [Microchip Developer Help — Graphics](https://developerhelp.microchip.com/xwiki/bin/view/software-tools/mgs/mgs-harmony-guide/gfx-assets/).
- Згенеровані шрифти **без змін** сумісні з GUI_GSP: структура `lv_font_t` та формат lv_font_fmt_txt збігаються з використовуваним у бібліотеці.

### 3.6. UTF-8 та вивід тексту

Вивід тексту йде через **DrawTextUTF8** та пов’язані функції (**GSP_DrawText.c**) з підтримкою **UTF-8**. Шрифт передається як `lv_font_t *font`. Для кирилиці та інших символів у шрифті при конвертації потрібно вказати відповідний діапазон гліфів у Font Converter.

**Підсумок по [LVGL](https://lvgl.io/):** бібліотека використовує ті самі шрифти та формат, що й LVGL 8.x. Можна застосовувати лише вбудовані шрифти, лише завантажувані з FLASH або комбінацію; шрифт за замовчуванням задається **DEFAULT_FONT** у конфігу.

---

## 4. Для кого ця інструкція

- Ви портуєте проект з GUI_GSP на **інший мікроконтролер** або **інший дисплей**.
- Ви підключаєте бібліотеку GUI_GSP до **нового проекту**.
- Ви хочете зрозуміти, **що саме потрібно реалізувати** зі свого боку.

**Що не потрібно:** писати низькорівневу графіку (точки, лінії, прямокутники, картинки) — це вже зроблено в бібліотеці. Потрібно лише **ініціалізувати дисплей** та **виводити готовий кадр** на екран.

---

## 5. Головна ідея портування

Бібліотека зберігає **один буфер кадру** (масив пікселів) і сама малює в нього віджети, текст та графіку. Ваше завдання — **дві дії**:

| № | Ваша функція | Що вона робить |
|---|--------------|----------------|
| 1 | **Init_LCD()** | Один раз при старті налаштовує дисплей (пини, SPI/I2C, команди контролера). |
| 2 | **Refresh_LCD(buffer)** | За викликом бібліотеки відправляє готовий буфер кадру на фізичний дисплей. |

Схема роботи:

```
  Ваш застосунок (екрани, кнопки)
           │
           ▼
  Бібліотека GUI_GSP (віджети, малювання в буфер Mem_LCD[])
           │
           ▼
  GSP_Display_Refresh()  ──►  викликає вашу Refresh_LCD(Mem_LCD)
           │
           ▼
  Ваш код: відправка буфера по SPI/I2C/паралельному порту на дисплей
```

**Важливо:** функції PutPixel, Line, Bar, SetColor тощо **реалізовувати не потрібно** — вони вже є в бібліотеці та працюють з її єдиним буфером.

---

## 6. Швидкий старт

1. **Створити** свій модуль дисплея (наприклад, `Graphics/MyDisplay.c` та `MyDisplay.h`).
2. **Реалізувати** у ньому:
   - `void Init_LCD(void)` — ініціалізація заліза.
   - `void Refresh_LCD(unsigned char *buffer)` — вивід `buffer` на дисплей (розмір та формат — розділ 8).
3. **Задати** у `GUI_GSP/Config/GUI_GSP_Config.h` розміри: `SCREEN_HOR_SIZE`, `SCREEN_VER_SIZE`.
4. **У** `GUI_GSP/Drivers/GSP_Hardware.c`:
   - підключити ваш заголовок з оголошеннями `Init_LCD` та `Refresh_LCD`;
   - у структурі **GSP_HW** вказати: `.display.Init = Init_LCD`, `.display.Refresh = GSP_Display_Refresh`.
5. **Додати** ваш `MyDisplay.c` до збірки проекту.

Далі — розділ 7 (покрокові кроки).

---

## 7. Покрокове портування

### Крок 1. Створити модуль дисплея

- **Заголовок** (наприклад, `Graphics/MyDisplay.h`):

```c
#ifndef MY_DISPLAY_H
#define MY_DISPLAY_H

void Init_LCD(void);
void Refresh_LCD(unsigned char *buffer);

#endif
```

- **Реалізація** (наприклад, `Graphics/MyDisplay.c`): власна ініціалізація (GPIO, SPI, команди контролера) та відправка буфера на дисплей. Приклад заглушки:

```c
#include "MyDisplay.h"

void Init_LCD(void)
{
    // Налаштувати пини (CS, DC, RST, CLK, DATA…)
    // Налаштувати SPI або інший інтерфейс
    // Відправити послідовність команд ініціалізації контролера
}

void Refresh_LCD(unsigned char *buffer)
{
    // buffer — масив розміром (SCREEN_HOR_SIZE * SCREEN_VER_SIZE) / 8 байт
    // Відправити на дисплей: посторінково або цілком — як вимагає контролер
}
```

Розмір та формат буфера — розділ 8.

---

### Крок 2. Задати розміри екрана

У **`GUI_GSP/Config/GUI_GSP_Config.h`**:

```c
#define SCREEN_HOR_SIZE    128   // ширина в пікселях
#define SCREEN_VER_SIZE    64    // висота в пікселях
```

Розмір буфера: **SIZE_DISP = (SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8** байт (для 128×64 — 1024 байти).

---

### Крок 3. Підключити дисплей у GSP_Hardware

У **`GUI_GSP/Drivers/GSP_Hardware.c`**:

1. Підключити заголовок з `Init_LCD` та `Refresh_LCD`.
2. У структурі **GSP_HW** у блоці `.display` задати:
   - **Refresh** = **GSP_Display_Refresh** (бібліотека всередині викличе вашу **Refresh_LCD(Mem_LCD)**);
   - **Init** = **Init_LCD**.

Інші поля (клавіатура, stream_reader, memory_read, alloc/free) — за потреби (розділ 9).

---

### Крок 4. Додати файли до проекту

У налаштуваннях проекту додати до збірки ваш модуль дисплея (наприклад, `MyDisplay.c`). При заміні старого дисплея — прибрати з збірки старий модуль.

---

## 8. Формат буфера екрана

У **Refresh_LCD(unsigned char *buffer)** передається буфер із вже намальованим кадром.

- **Розмір:** `SIZE_DISP = (SCREEN_HOR_SIZE * SCREEN_VER_SIZE) / 8` байт.
- **Організація (1 bpp, монохром):** один байт — 8 пікселів по вертикалі (сторінка висотою 8 рядків). Пікселі по стовпцях: стовпець 0 рядки 0–7, потім стовпець 1 рядки 0–7 тощо.

**Індекс байта:** `індекс = (y / 8) * SCREEN_HOR_SIZE + x` (x — стовпець, y — рядок).  
**Біти в байті:** молодший біт (bit 0) — менший y у вісімці, старший (bit 7) — більший y.

**Значення пікселя:** біт = 1 — світлий, біт = 0 — темний. Багато контролерів (SSD1306, SH1107) використовують такий самий формат; інакше перетворення робиться всередині вашої **Refresh_LCD**.

---

## 9. Додаткові можливості

У **GSP_Hardware.c** окрім дисплея налаштовуються:

- **Клавіатура** — `.keyboard.key_poll`, `.keyboard.read_key`; в застосунку — **GSP_KeyPoll()**, **GSP_ReadKey()**.
- **Підсвітка** — реалізація **SetBright(light)** у вашому модулі (або заглушка).
- **Зовнішня пам'ять** — **memory_read** (callback читання за зміщенням та довжиною), **stream_reader** (потокове читання для JSON тощо).
- **Алокатор** — **GSP_HW.alloc**, **GSP_HW.free** (за замовчуванням можна використовувати malloc/free або, наприклад, **user_malloc/user_free** з **GSP_mem_monitor**).

Невикористані вказівники можна залишати **NULL**; бібліотека перевіряє їх перед викликом.

---

## 10. Подробиці: віджети, пам'ять, таймер

### 10.1. Конфігурація віджетів та кольорів

У **GUI_GSP/Config/GUI_GSP_Config.h** задаються макроси **USED_*** (USED_LABEL, USED_TABLE, USED_LIST, USED_CHART, USED_IMAGE, USED_PROGRESSBAR, USED_SPINNER, USED_PANEL, USED_LINE, USED_TIMER, USED_MESSAGE, USED_KEYBOARD). Вимкнення непотрібних віджетів зменшує розмір коду. Там же — кольори за замовчуванням (DEFAULT_COLOR_*) та опції графіків (CHART_ENABLE_*).

### 10.2. Зовнішня пам'ять: шрифти та зображення

Читання даних з FLASH/зовнішньої пам'яті — через **ExternalMemoryCallback** (сигнатура в конфігу), присвоюється в **GSP_HW.memory_read**. Використовується завантажувачем шрифтів (**lv_font_load**) при **USE_FONT_FLASH** та виводом зображень (**PutImage**) при **USE_BITMAP_EXTERNAL**.

### 10.3. Формат шрифту у зовнішній пам'яті

Шрифт у зовнішній пам'яті має бути у **бінарному форматі [LVGL](https://lvgl.io/)** (експорт [LVGL Font Converter](https://lvgl.io/tools/fontconverter) у **Binary**). Структура: секції head, cmap, loca, glyph (та опційно kern). Завантажувач **lv_font_load** читає їх через **ExternalMemoryCallback**; за адресою **EXTDATA.address** має лежати цілий бінарний файл шрифту LVGL. Дані для запису у FLASH (шрифти, зображення) можна готувати утилітою [Microchip](https://www.microchip.com/) **grc.jar** (Graphics Resource Converter); див. [документацію Microchip з графічних ресурсів](https://developerhelp.microchip.com/xwiki/bin/view/software-tools/mgs/mgs-harmony-guide/gfx-assets/).

### 10.4. Формат зображення у зовнішній пам'яті

При **USE_BITMAP_EXTERNAL**: за адресою **EXTDATA.address** — заголовок (compression, colorDepth, height, width), палітра (два unsigned short для 1 bpp), потім побудовочно дані 1 bpp. Читання — через **ExternalMemoryCallback**.

### 10.5. Віджет GSP_Timer

При опції **USED_TIMER** доступний віджет **GSP_Timer** — таймери, прив’язані до екрана. Вони періодично викликають заданий callback і зручні для оновлення даних, опитування датчиків або синхронізації з анімацією.

- **CreateTimer(Screen, TimerFuncPtr, period_ms, count)** — створити таймер: виклик `TimerFuncPtr(timer)` кожні `period_ms` мс; `count` — кількість спрацювань (−1 — безкінечно).
- **DeleteAllTimers(Screen)**, **PauseAllTimers(Screen)**, **ResumeAllTimers(Screen)** — видалити всі таймери екрана, призупинити або відновити.
- **Set_GSP_Timer_Period(Timer, period)** — змінити період таймера.

Таймери обробляються всередині **GUI_Run()** за глобальним лічильником **Timer_GUI**, який оновлюється викликом **GUI_TimerClock(period_ms)** в обробнику переривання таймера (див. п. 10.7).

### 10.6. Анімація виводу картинок (Image)

Віджет **Image** підтримує **анімацію** — почерговий вивід кадрів (масив картинок) із заданим інтервалом. Таймінг базується на **Timer_GUI**, тому для роботи анімації в перериванні таймера має викликатися **GUI_TimerClock(period_ms)**.

- **Режими анімації** (GSP_Image.h): **GSP_ANIM_MODE_LOOP** (цикл), **GSP_ANIM_MODE_ONCE** (один раз, потім зупинка), **GSP_ANIM_MODE_PINGPONG** (туди-назад), **GSP_ANIM_MODE_REVERSE** (зворотний цикл).
- **ImageSetFrames(img, frames, n, time)** — задати масив кадрів `frames`, кількість кадрів `n`, інтервал між кадрами `time` (мс).
- **ImageSetFramesEx(img, frames, n, time, mode)** — те саме з явним режимом анімації.
- **ImageStartAnimation(img)**, **ImageStopAnimation(img)**, **ImagePauseAnimation(img)**, **ImageResumeAnimation(img)**, **ImageRestartAnimation(img)** — керування відтворенням.
- **ImageSetAnimationMode(img, mode)** — зміна режиму; **ImageGetCurrentFrame(img)**, **ImageIsAnimationPlaying(img)** — стан анімації.

Мигання віджета Image задається **ImageSetBlink(img, blink_time)** (0 — вимкнути).

### 10.7. Таймер та основний цикл

- **В основному циклі** має викликатися **лише** **GUI_Run()** — всередині нього виконуються опитування клавіатури, оновлення екрана та вся логіка GUI.
- **В обробнику переривання таймера** обов’язково викликати **GUI_TimerClock(period_ms)** з параметром, рівним періоду переривання в мілісекундах (наприклад, при періоді 10 мс — **GUI_TimerClock(10)**). Це потрібно для роботи віджетів **GSP_Timer**, анімації зображень (Image) та інших віджетів, що використовують Timer_GUI.

Приклад: основний цикл та виклик у таймері:

```c
// Основний цикл застосунку — лише GUI_Run()
while (1) {
    GUI_Run();
}

// В обробнику переривання таймера (період, наприклад, 10 мс):
GUI_TimerClock(10);   // 10 — період переривання в мс
```

---

## 11. Чек-лист та важливі файли

### Чек-лист портування

- [ ] Створено модуль дисплея з **Init_LCD()** та **Refresh_LCD(unsigned char *buffer)**.
- [ ] У конфігу задані **SCREEN_HOR_SIZE** та **SCREEN_VER_SIZE**.
- [ ] У **GSP_Hardware.c** підключено заголовок та задані **GSP_HW.display.Refresh = GSP_Display_Refresh**, **GSP_HW.display.Init = Init_LCD**.
- [ ] За потреби заповнені клавіатура, stream_reader, memory_read, alloc/free, SetBright.
- [ ] Модуль дисплея додано до збірки.

### Важливі файли

| Файл | Призначення |
|------|-------------|
| **GUI_GSP/Drivers/GSP_Driver.h**, **GSP_Driver.c** | Буфер Mem_LCD, графіка, виклик Refresh_LCD та Init_LCD. |
| **GUI_GSP/Drivers/GSP_Hardware.c** | Налаштування GSP_HW під проект (дисплей, клавіатура, пам'ять, алокатор). |
| **GUI_GSP/Config/GUI_GSP_Config.h** | Розміри екрана, кольори, шрифти, опції віджетів. |
| **GUI_GSP/Fonts/Fonts.h**, **Fonts/LVGL/GSP_lvgl.h** | Шрифти [LVGL](https://lvgl.io/), тип lv_font_t. |
| **GUI_GSP/Fonts/LVGL/GSP_lv_font_loader.c** | lv_font_load / lv_font_free для завантаження шрифтів з FLASH. |

---

## 12. Підключення у вашому коді

```c
#include "GUI_GSP/GUI_GSP.h"
#include "Langs.h"
```

Через **GUI_GSP.h** підтягуються конфіг, драйвер та віджети.

---

## 13. Часті питання

**Чи потрібно реалізовувати PutPixel, Line, Bar?**  
Ні. Вся графіка в бібліотеці, малює в один буфер. Потрібні лише Init_LCD та Refresh_LCD.

**Що передається в Refresh_LCD?**  
Вказівник на буфер бібліотеки (Mem_LCD). Розмір: **(SCREEN_HOR_SIZE × SCREEN_VER_SIZE) / 8** байт. Формат — розділ 8.

**Чи можна інший розмір екрана?**  
Так. Задайте **SCREEN_HOR_SIZE** та **SCREEN_VER_SIZE** у конфігу.

**Немає клавіатури / потокового читання / зовнішньої пам'яті.**  
Відповідні поля в GSP_HW можна залишити NULL.

**Контролер дисплея очікує інший порядок сторінок або бітів.**  
Перетворення робіть всередині вашої **Refresh_LCD**.

**Чи можна використовувати шрифти LVGL?**  
Так. Бібліотека повністю сумісна зі шрифтами [LVGL](https://lvgl.io/) (lv_font_t, lv_font_fmt_txt): вбудовані з **Fonts.h**, **DEFAULT_FONT** у конфігу, при **USE_FONT_FLASH** — завантаження з FLASH через **lv_font_load**. Детально — розділ 3.

---

*Кінець керівництва.*
